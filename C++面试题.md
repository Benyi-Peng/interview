C++
lambda相关：
1.可将lambda理解为一个未命名的内联函数；
2.lambda的形式是[capture list] (parameter list) -> return type { function body }，其中参数列表和返回类型可以忽略，但一定要有捕获列表和函数体；
3.捕获分为值捕获和引用捕获，当以引用方式捕获一个变量（比如指针或者迭代器），调用lambda时必须保证绑定到指针、迭代器、引用的对象仍然存在；
4.如果希望能改变一个被捕获的变量的值，就必须在参数列表前加上关键字mutable。

vector底层实现：
只有当操作需求超出了vector的容量时，才会扩容。一般情况下，在复制元素的时候调用元素的拷贝构造函数。当元素实现了移动构造函数时，并将移动构造函数标记为noexcept时（保证移动构造函数不会抛出异常），调用元素的移动构造函数。
原因：
除了完成资源移动，移动构造函数还必须保证移后源对象处于这样一个状态-----销毁它是无害的。所以，在移动构造函数里，需要保证移后源对象的指针成员变量不再指向被移动的资源。也就是说，移动构造函数会改变移后源对象。

为了让我们自己的类支持移动操作，需要为其定义移动构造函数和移动赋值运算符。
有一个类MyClass，其有一个成员变量是指针Ptr，指向一块堆上的内存空间。在MyClass的析构函数中，会释放这块堆上的空间。

现在有一个MyClass的实例A，通过移动构造函数我们得到了实例B。此时A.Ptr和B.Ptr均指向同一块空间。如果不将A.Ptr置空，未来A被析构的时候会释放掉这块空间，B.Ptr变成野指针。

解释：
vector对外保证，在调用push_back导致的扩容过程中如果发生异常，vector自身不会发生变化。意即，如果扩容复制的过程中发生意外，vector会销毁已经拷贝到新空间的对象，原来旧空间的对象还在且保持不变。这是vector对外保证的。
而移动构造函数会对改变旧对象，所以只要当移动构造函数保证不会出现异常的时候，vector才会调用移动构造函数。



为什么基类的析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数
https://zhuanlan.zhihu.com/p/28530472
由上文可知，当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时根据实际类型调用子类的析构函数，可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

C++面试之虚函数
https://zhuanlan.zhihu.com/p/28530472
https://zhuanlan.zhihu.com/p/75172640

每个类，有他自己的虚表。




https://blog.csdn.net/suyinfan/article/details/80634613
虚函数表存储在内存的全局数据段（存放已初始化的数据）。
有了对象指针，如何获取虚表地址？
根据编译器的不同，方法也不同。在一般的编译器下，对象存储空间的第一个字存储的即为虚函数表地址。




vector和list有什么区别？

Vector:顺序表

优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。
缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。

List：链表

优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)
缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n），没有提供[]操作符的重载。

为什么要内存对齐？
https://www.pengrl.com/p/20020/

哈希表的底层实现
http://c.biancheng.net/view/7235.html


TCP和UDP区别，应用场景
	是否面向连接	可靠性	传输形式	传输效率	消耗资源	应用场景	首部字节
TCP	面向连接	可靠	字节流	慢	多	文件/邮件传输	20~60
UDP	无连接	不可靠	数据报文段	快	少	视频/语音传输	8






网易：
拷贝构造函数可以是虚函数吗
https://blog.csdn.net/qq_28584889/article/details/88749862
虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。

静态成员函数可以是虚函数吗
https://blog.csdn.net/shltsh/article/details/45999801
不能，将静态成员函数声明为virtual，编译会报错。静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。
   虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。
   对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。


自定义的类加入unordered_map需要做什么工作
https://blog.csdn.net/weixin_40673608/article/details/100576551
https://zhuanlan.zhihu.com/p/355552490
1.定义哈希函数的函数对象（第三个参数），具体就是定义一个类，重载调用运算符，返回一个size_t。这一步的目的是提供对自定义类进行hash的方法；
2.定义比较函数的函数对象（第四个参数），或者在自定义类里重载operator==()，判定是否冲突；

什么是TIME_WAIT状态



TCP、UDP能同时用一个端口吗
可以。一个进程可以使用同一端口，同时监听tcp、udp请求。因为端口的唯一性的标识不是端口号，而是端口号和协议名称的组合，应用程序和协议寻址时就是靠的这个组合。


僵尸进程、孤儿进程、守护进程
线程共享的资源有哪些

unordered_map和map的区别
https://www.jianshu.com/p/f602d53f081a
https://blog.csdn.net/qq_26591517/article/details/79621348
https://www.jianshu.com/p/f602d53f081a
map是有序的，底层使用的红黑树，map需要对key进行相互比较，从而确定具体插入的位置，所以map的key值需要支持比较函数。而pair重载了相对应的比较操作符，所以作为map的key没有问题
相反，unordered_map是无序的，是基于哈希表的数据结构，unordered_map需要对key进行hash函数，利用hash出的唯一值确定插入对象的位置，所以unordered_map的key值需要支持hash函数，pair就不行。


用什么命令查看端口的占用情况

手写一个拷贝构造函数
手写一个拷贝赋值操作符
D:\program\qt_program\untitled\test4.cpp
在上面这个文件里，有值语义的、也有指针语义的。


如果客户端或者服务端宕机了，另一端如何发现连接中断？
1.对端一直宕机，则自己的内核协议栈返回对端不可达，可自行设置超时时间；
2.对端宕机一会儿又上线，由对端RST字段告知连接已经废弃。

服务器CPU飙高，如何查找存在的问题？
1.使用top命令查询出当前CPU占用最多的进程，记住进程号；
2.使用top命令（top -Hp 进程号）查看该进程中哪些线程CPU占比高，记录线程号；
3.根据线程号查看线程函数调用栈信息（jstack 进程号 | grep ...）
4.还有其他命令查看内存的使用情况、内存中创建的对象等等。。。

new/delete 和 malloc/free的区别？
1.new/delete是C++的操作符，malloc/free是标准库函数；
2.new在申请内存空间后，还会调用构造函数来初始化内存空间。delete在释放内存空间之前，会调用析构函数。而malloc/free只能用来申请、释放内存空间。
3.new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。

push_back的具体流程
push_back引用和普通对象的区别

洗牌算法

一个基类的指针指向一个派生类对象，他这个虚函数怎么装填进去的
一个派生类继承于两个基类，他的虚函数表怎么填装
https://blog.csdn.net/qq_36359022/article/details/81870219
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。
派生类如果不重写任何虚函数，它的对象里的虚表指针所指向的虚表里面的虚函数指针都指向基类的虚函数。如果它自己重写了某个虚函数，对应的虚函数指针指向自己的实现。
每个类的对象的虚表指针指向自己的虚表。
在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。
当有多个虚函数表时，虚函数表的结尾是0代表没有下一个虚函数表。" * "号位置在不同操作系统中实现不同，代表有下一个虚函数表。
注意：
1.子类虚函数会覆盖每一个父类的每一个同名虚函数。
2.父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。
3.父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。


一个基类指针，可以cast到派生类对象吗
函数模板和函数重载的区别
为什么右值引用会减少拷贝
动态链接和静态链接的区别
动态库动态链接，程序运行后，是怎么具体找到要调用动态库哪个函数的




三次握手，短时间有大量的客户端要去连接服务器会发生什么
SYN Flood攻击
下面这个链接很全面的介绍TCP相关的面试题
https://segmentfault.com/a/1190000023565467
HTTP:
https://segmentfault.com/a/1190000038323994

C++中的4种cast：
static_cast

dynamic_cast:
1. 返回空指针来表示转换失败。倘若是无法完成的引用转换，则会抛出bad_cast 异常；
2. dynamic_cast 也能够完成空指针在任意指针类型上的转换，以及任意指针类型向void*的转换。

reinterpret_cast
const_cast

半连接、全连接队列满后的行为：
https://www.cnblogs.com/xiaolincoding/p/12995358.html

TCP保活
https://tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/




小米：
什么时候调用拷贝构造函数
1.用赋值运算符定义变量；
2.传参，如果形参不是引用类型，将实参的值拷贝后赋给形参；
3.从一个返回类型为非引用类型的函数返回一个对象；
4.用花括号列表初始化一个数组中的元素，或一个聚合类中的成员；
5.初始化标准库容器或者调用push、insert成员时，容器会对其元素进行拷贝初始化。

什么时候调用析构函数：
无论何时一个对象被销毁，就会自动调用其析构函数。
1.变量离开作用域；
2.当一个对象被销毁，其成员被销毁；
3.容器（标准库、数组）销毁时，其元素被销毁；
4.对于动态分配的对象，当对指向他的指针应用delete运算符时被销毁；
5.对于临时对象，当创建它的完整表达式结束时被销毁。
6.析构函数体自身并不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。

拷贝构造函数参数为什么是引用
1.首先，拷贝构造函数参数不能是一个对象本身。如果是对象本身，拷贝函数会在传参的过程中再次调用拷贝函数，形成无限循环；
2.其次，拷贝构造函数参数如果设置为指针，相当于新定义了另外一个构造函数。该函数不再是拷贝构造函数。当显式调用该类的拷贝构造、传参、返回对象时，调用的是编译器的合成拷贝构造函数，而不是参数为指针的这个函数。
https://blog.csdn.net/qq_21148843/article/details/79794695

三五法则：
如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。

vector的reserve和resize的区别：
reserve并不改变容器中元素的数量，它仅仅影响vector预先分配多大的内存空间。
只有当参数大于当前空间容量，reserve才会改变vector的容量；否则，reserve什么也不做。

resize只改变容器中元素的数目，当resize的第一个参数大于容器容量时，才会改变容器大小。


unordered_map内部实现、扩容
三次握手、四次挥手

两次可不可以
1.假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。
2.如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。

Bind accept listen connect函数对应三次握手中的哪些环节
客户端、服务端均先调用socket函数，生成一个socket。
1.服务器bind一个众所周知的地址，用于提供服务，然后调用listen函数，开始监听；
2.客户端connect对应第一次握手，其中connect会自动分配一个端口号和自身IP地址组合给进程，所以客户端不用bind；
3.服务端接收到客户端的第一次握手消息后，调用accept，是为第二次握手；
4.客户端收到消息后，可以调用send、recv等函数跟服务器通信，是为第三次握手；

https://www.codenong.com/cs105364662/
https://www.bilibili.com/video/BV1qJ411w7du?from=search&seid=12899915721320129326
https://www.processon.com/view/link/5f36856b5653bb06f2ce529f
https://blog.csdn.net/XueyinGuo/article/details/113096163
Select epoll
IO 多路复用的本质是通过一种机制，让单个进程可以监视多个描述符，当发现某个描述符就绪之后，能够通知程序进行相应的读写操作。

select使用流程：
1.用bitmap来表示读、写、异常文件描述符集合，传给select函数；
2.select函数是一个阻塞函数，当没有数据时，会一直阻塞在select那一行；
3.有数据时，select返回，然后遍历文件描述符，从有数据的文件描述符读数据。
缺点：
1.bitmap默认大小是1024，虽然可以调整但是还是有限度；
2.每次调用select前，需要花费0（n）的时间重新设置bitmap；
3.描述符集合整体在用户空间和内核空间来回拷贝，也比较费时；
4.当有数据可以用的时候select会返回，但是不知道哪个文件描述符有数据可读。需花费O（n）的时间来遍历文件描述符集合；

poll使用流程：
用pollfd这个结构体来描述我们关心的文件描述符。pollfd结构体除了文件描述符字段，还有一个events字段和revents字段。events字段表示我们关心该文件描述符上发生的什么事件，revents是在poll函数返回时，表明发生的事件。使用流程与select类似。

改进：
1.由于使用了一个pollfd结构体数组来表示文件描述符集合，而不是bitmap，poll函数监听的文件描述符数量不受限制；
2.调用poll之前，也不用花费O（n）时间去重置bitmap；
缺点：
1.类似的，描述符集合整体在用户空间和内核空间之前来回拷贝；
2.当有数据返回时，poll函数也不知道是哪个文件描述符有数据可用，需要O（n）的时间来遍历文件描述符集合；

epoll使用流程：
epoll有三个函数，epoll_create、epoll_ctl、epoll_wait。先调用epoll_create，然后调用epoll_ctl来表明我们关心的文件描述符及其发生的事件。然后调用epoll_wait。epoll_wait返回一个int值，表示有多少个文件描述符有数据可用，假设返回3。epoll_wait还有一个参数是一个结构体数组，epoll_wait返回时，会在这个数组中放入3个有数据可用的文件描述符。我们只需要遍历处理这三个描述符就行。
改进：
1.描述符集合整体在第一次拷贝进内核空间后，用红黑树来组织这些描述符，加快查找速度，当查找到有数据的描述符后，将这个描述符放入一个ready list（链表），最后只需要将有数据可用的描述符拷贝回用户空间即可。不会将所有描述符来回拷贝；
2.有数据返回时，我们可以知道是哪几个描述符有数据，只需花费O（1）时间来处理即可。

epoll的LT、ET模式：
LT：默认的模式。水平触发。只要该fd还有数据可读，每次epoll_wait都会返回它的事件，提醒用户程序去操作；
ET：边缘触发。当该fd有数据可读时，epoll_wait提示一次。不管数据是否读完，直到下次该fd又有数据可读。


什么是索引
聚簇索引、非聚簇索引

Linux查看内存 、CPU 、负载的命令
top、cat proc/meminfo 查看内存
lscpu 查看CPU
vmstat

Linux如何查看内存泄漏

中断、软中断、硬中断
1.由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。
2.为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理时间比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。




网卡接受到数据是软中断、还是硬中断，操作系统怎么操作的
进程与线程的关系和区别

线程独有的资源？共享的资源？
线程共享的环境包括：
进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
线程独有的：
 1.线程ID
      每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标
   识线程。
 2.寄存器组的值
       由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线
   程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便
   将来该线程在被重新切换到时能得以恢复。
3.线程的堆栈
       堆栈是保证线程独立运行所必须的。
       线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程
   必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影
   响。
4.错误返回码
       由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用
   后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时
   被调度器投入运行，这样错误值就有可能被修改。
       所以，不同的线程应该拥有自己的错误返回码变量。
5.线程的信号屏蔽码
       由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。
6.线程的优先级
       由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。


进程间通信的方式
线程的同步方式





move和forward的区别：


C++左值、右值
https://blog.csdn.net/hyman_yx/article/details/52044632


互斥条件：一个资源一次只能被一个进程使用
请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系


